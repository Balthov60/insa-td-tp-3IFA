#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <semaphore.h>
#include <pthread.h>
#include <unistd.h>

#include "bag.h"

bag_t * bb_create(int size)
{
    assert(size > 0);
    
    bag_t *bag=malloc(sizeof(bag_t));
    assert(bag != NULL);

    bag->elem = malloc( size * sizeof(void*));
    assert(bag->elem);
    bag->bagMutex = dispatch_semaphore_create(1);

    bag->size  = size;
    bag->sizeSemaphore = dispatch_semaphore_create(size);

    bag->count = 0;
    bag->countSemaphore = dispatch_semaphore_create(0);

    bag->is_closed = 0;
    bag->closedMutex = dispatch_semaphore_create(1);

    return bag;
}

void bb_add(bag_t * bag, void * element)
{
    assert(bag != NULL);                 // sanity check

    dispatch_semaphore_wait(bag->sizeSemaphore, DISPATCH_TIME_FOREVER);
    
    assert( bag-> is_closed == 0 );   // adding to a closed bag is an error
    assert( bag->count < bag->size ); // sanity check

    dispatch_semaphore_wait(bag->bagMutex, DISPATCH_TIME_FOREVER);
    bag->elem[bag->count] = element;
    bag->count += 1;
    dispatch_semaphore_signal(bag->bagMutex);

    dispatch_semaphore_signal(bag->countSemaphore);
}

void * bb_take(bag_t *bag)
{
    assert(bag != NULL); // sanity check

    /* TAKE */
    dispatch_semaphore_wait(bag->countSemaphore, DISPATCH_TIME_FOREVER);

    /* CLOSE */
    dispatch_semaphore_wait(bag->closedMutex, DISPATCH_TIME_FOREVER);
    int isClosed = bag->is_closed;
    dispatch_semaphore_signal(bag->closedMutex);
    if (isClosed)
        return NULL;

    assert( bag->count > 0); // sanity check

    dispatch_semaphore_wait(bag->bagMutex, DISPATCH_TIME_FOREVER);
    bag->count -= 1;
    void *r = bag->elem[bag->count];
    dispatch_semaphore_signal(bag->bagMutex);

    dispatch_semaphore_signal(bag->sizeSemaphore);

    usleep(10);// artificial delay to increase the occurence of race conditions
    return r;
}

void bb_close(bag_t *bag, int N)
{
    dispatch_semaphore_wait(bag->closedMutex, DISPATCH_TIME_FOREVER);
    if (bag->is_closed)
        return;

    bag->is_closed = true;
    dispatch_semaphore_signal(bag->closedMutex);

    int i;
    for (i = 0; i < N; i++)
    {
        dispatch_semaphore_signal(bag->countSemaphore);
    }
}
